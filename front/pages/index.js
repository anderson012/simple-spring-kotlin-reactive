import Head from "next/head";
import Image from "next/image";
import styles from "../styles/Home.module.css";
import "@fontsource/roboto"; // Defaults to weight 400.
import {
  Button,
  Container,
  Fade,
  Grid,
  CircularProgress,
  Typography,
  Link,
  Card,
  CardContent,
  List,
  ListItem,
  ListItemText,
  LinearProgress,
  Grow,
} from "@material-ui/core";
// import { Alert, AlertTitle } from "@material-ui/lab";

import { fetchHeroes, saveDefaultItems, streamHeroesFromServer } from "./api/backend";
import { useRef, useState } from "react";
import { useSnackbar } from "notistack";

export default function Home() {
  const [saving, setSaving] = useState(false);
  const [fetching, setFetching] = useState(false);
  const [items, setItems] = useState([]);
  const loadStats = useRef({
    start: 0,
    end: 0,
  });

  const { enqueueSnackbar, closeSnackbar } = useSnackbar();

  const onClickSaveItems = async () => {
    setSaving(true);
    try {
      await saveDefaultItems();
      enqueueSnackbar("All itens inserted", {
        variant: "success",
      });
    } catch (e) {
      console.error(e);
      closeSnackbar("saving");
      enqueueSnackbar(e.message + " verify console for more info", {
        variant: "error",
      });
    } finally {
      setSaving(false);
    }
  };

  const onClickFetchData = async () => {
      setFetching(true);
      setItems([]);
      loadStats.current = {
        start: Date.now(),
        end: 0,
      }
      try {
          const heroes = await fetchHeroes();
          setItems(heroes);
          loadStats.current.end = Date.now();
          enqueueSnackbar("All itens fetched", {
              variant: "success",
          });
      } catch (e) {
          console.error(e);
          closeSnackbar("fetching");
          enqueueSnackbar(e.message + " verify console for more info", {
              variant: "error",
          });
      } finally {
        setFetching(false);
      }
  }

  const onClickStreamData = async () => {
    try {
      setItems([]);
      setFetching(true);
      loadStats.current = {
        start: Date.now(),
        end: 0,
      }

      const onmessage = (data) => {
        if (loadStats.current.end === 0) {
          loadStats.current.end = Date.now();
        }
        setItems(items => [...items, data]);
      };

      await streamHeroesFromServer(onmessage);
      enqueueSnackbar("All itens fetched", {
          variant: "success",
      });
      
    } catch (e) {
      closeSnackbar("streaming");
      enqueueSnackbar(e.message + " verify console for more info", {
        variant: "error",
      });
    } finally {
      setFetching(false);
    }
  };

  const disable = saving || fetching;
  return (
    <Container>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <h1 className={styles.title}>
          Kotlin with{" "}
          <a
            href="https://www.google.com/search?q=reactive+programming+webflux"
            target={"_blank"}
            rel="noreferrer"
          >
            reactive programming
          </a>
        </h1>
        <p className={styles.description}>Start by</p>
        <Button
          disabled={disable}
          variant="outlined"
          color="primary"
          onClick={onClickSaveItems}
        >
          saving the preset heroes to the database.
          <Fade in={saving}>
            <CircularProgress
              size={20}
              variant="indeterminate"
              color="primary"
            />
          </Fade>
        </Button>
        <Typography variant="caption">
          Will save a list of heroes on the databases. Just do it one time!
        </Typography>
        <br />
        And
        <br />
        <br />
        <br />
        <Container maxWidth="md">
          <Grid container direction="row" justifyContent="center" spacing={2}>
            <Grid item xs={12} md={5}>
              <Button
                disabled={disable}
                fullWidth
                variant="contained"
                color="primary"
                onClick={onClickStreamData}
              >
                List all itens with `EventSource` api
              </Button>
              <Typography variant="caption">
                Will use the{" "}
                <Link
                  target={"_blank"}
                  href="https://developer.mozilla.org/pt-BR/docs/Web/API/EventSource"
                  rel="noreferrer"
                >
                  EventSource
                </Link>{" "}
                api to listen for changes on the database. It returns items by a
                stream
              </Typography>
            </Grid>
            <Grid item xs={12} md={1}>
              <Typography align="center" variant="subtitle2">
                OR
              </Typography>
            </Grid>
            <Grid item xs={12} md={5}>
              <Button
                disabled={disable}
                fullWidth
                variant="outlined"
                color="secondary"
                onClick={onClickFetchData}
              >
                List all itens with `Fetch` api
              </Button>
              <Typography variant="caption">
                Will use the `Fetch` api to get the list of items and will only
                return them when all items are found in the database.
              </Typography>
            </Grid>
            {/* <Grid item xs={12}>
              <Alert severity="info" variant="outlined" style={{width: "100%"}}>
                <AlertTitle>Information</AlertTitle>
                  Click on a buttom to get the items from server
              </Alert>
            </Grid> */}
            <Grid item xs={12}>
              <Card variant="outlined" elevation={3} style={{minHeight: 500}}>
                <Fade in={fetching}>
                  <LinearProgress />
                </Fade>
                <CardContent>
                  {fetching && (<Typography style={{textAlign: "center"}} variant="caption">Receiving data...</Typography>)}
                  {items.length > 0 && (
                    <Typography variant="h5" component="h2">
                      First render after {loadStats.current.end - loadStats.current.start}ms
                    </Typography>
                  )}
                  <List>
                    {items.map((item, i) => (
                      <Grow in timeout={1000}  key={item.id}>
                        <ListItem>
                          <ListItemText primary={item.nickname} secondary={<>
                            <Typography variant="caption">
                              {item.realName}
                            </Typography>
                            {` - ${item.superPower}`}
                          </>}  />
                        </ListItem>
                      </Grow>
                    ))}
                  </List>
                </CardContent>
              </Card>
            </Grid>
          </Grid>
          
        </Container>
      </main>
    </Container>
  );
}
